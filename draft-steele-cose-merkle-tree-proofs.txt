



TBD                                                            O. Steele
Internet-Draft                                                 Transmute
Intended status: Standards Track                             H. Birkholz
Expires: 8 December 2023                                  Fraunhofer SIT
                                                      A. Delignat-Lavaud
                                                              C. Fournet
                                                               Microsoft
                                                             6 June 2023


             Concise Encoding of Signed Merkle Tree Proofs
              draft-steele-cose-merkle-tree-proofs-latest

Abstract

   This specification describes three CBOR data structures for primary
   use in COSE envelopes.  A CBOR encoding of Merkle Roots for use in
   COSE payloads.  A CBOR encoding of Inclusions Proofs for use in COSE
   unprotected headers.  A CBOR encoding of Consistency Proofs for use
   in COSE unprotected headers.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Source for this draft and an issue tracker can be found at
   https://github.com/ietf-scitt/draft-steele-cose-merkle-tree-proofs.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 8 December 2023.

Copyright Notice

   Copyright (c) 2023 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Requirements Notation
   2.  Terminology
   3.  CBOR Merkle Structures
     3.1.  Inclusion Proof
     3.2.  Signed Inclusion Proof
       3.2.1.  Array form CDDL
     3.3.  Signed Consistency Proof
       3.3.1.  Array form CDDL
   4.  Merkle Tree Algorithms
     4.1.  The RFC9162_SHA256 Tree Algorithm
       4.1.1.  Tree Algorithm
       4.1.2.  Tree Definition
     4.2.  Signed Proofs
   5.  Privacy Considerations
     5.1.  Leaf Blinding
   6.  Security Considerations
     6.1.  Hash Function Agility
   7.  IANA Considerations
     7.1.  Additions to Existing Registries
       7.1.1.  New Entries to the COSE Header Parameters Registry
       7.1.2.  Tree Algorithms
   8.  References
     8.1.  Normative References
     8.2.  Informative References
   Appendix A.  Blinding Example
   Authors' Addresses

1.  Introduction

   Merkle trees are verifiable data structures that support secure data
   storage, through their ability to protect the integrity of batches of
   documents or collections of statements.

   A merkle proof is a path from a leaf to a root in a merkle tree.

   Merkle proofs can be used to prove a document is in a database (proof
   of inclusion), or that a smaller set of statements are contained in a
   large set of statements (selective disclosure proofs).

   Typically, merkle trees are constructed from simple operations such
   as concatenation and digest via a cryptographic hash function.

   The simple design and valuable cryptographic properties of merkle
   trees have been leveraged in many network and database applications.

   Differences in the representation of a merkle tree, merkle leaf and
   merkle inclusion proof can increase the burden for implementers, and
   create interoperability challenges.

   This document describes the three data structures necessary to use
   merkle proofs with COSE envelopes.

1.1.  Requirements Notation

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.  Terminology

   Leaf:  A merkle tree leaf is the cryptographic hash of a sequence of
      bytes that combines Leaf Payload and Extra Data.

   Merkle Tree:  A Merkle tree is a tree where every leaf is a
      cryptographic hash of a sequence of bytes and every node that is
      not a leaf is the cryptographic hash of the its child nodes.

   Merkle Root:  A Merkle root is the root node of a tree; this
      cryptographic hash is a committment to the content of the tree.

   Merkle Tree Algorithm:  A Merkle tree algorithm specifies how to
      construct the tree and how to compute its root.

   Leaf Payload and Extra Data:  A leaf payload is application data used
      to produce a Leaf.  The Merkle tree algorithm determines how a
      payload together with extra data is used to produce a leaf.  The
      simplest case is that the leaf is the cryptographic hash of the
      payload without extra data.

   Inclusion Path:  An inclusion path enables a verifier to recompute a
      root, given a leaf and extra data.

   Inclusion Proof:  An inclusion proof is a combination of the extra
      data, inclusion path and a merkle tree root.

   Signed Inclusion Proof:  A signed inclusion proof is a combination of
      the inclusion path and signed envelope that includes a merkle
      root.

3.  CBOR Merkle Structures

   This section describes representations of merkle proof structures in
   CBOR.

   Some of the structures such as the construction of a merkle tree
   leaf, or an inclusion proof from a leaf to a merkle root, might have
   several different representations.

   Some differences in representations are necessary to support
   efficient verification of different kinds of inclusion proofs and for
   compatibility with deployed tree algorithms used in specific
   implementations.

   In case of [RFC9162], this is defined in Section 2.1.1.  Definition
   of the Merkle Tree.

3.1.  Inclusion Proof

   [RFC6962] defines a merkle audit path for a leaf in a merkle tree as
   the shortest list of additional nodes in the merkle tree required to
   compute the merkle root for that tree.

   [RFC9162] changed the term from "merkle audit path" to "merkle
   inclusion proof".

   We prefer to use the term "inclusion path" to avoid confusion with
   Signed Inclusion Proof.

   For tree algorithm "RFC9162_SHA256", we define the following compact
   encoding of an inclusion proof for a leaf:

   inclusion-proof = #6.1234([
       tree-size: int
       leaf-index: int
       inclusion-path: [+ bstr]
   ])

   Leaf index is also sometimes referred to as sequence number.

3.2.  Signed Inclusion Proof

   A Merkle root is signed with COSE_Sign1:

   smtr = THIS.COSE.profile .and COSE_Sign1_Tagged

   Protected header parameters:

   *  alg (label: 1): REQUIRED.  Signature algorithm identifier.  Value
      type: int / tstr.

   *  tree_alg (label: TBD): REQUIRED.  Merkle tree algorithm
      identifier.  Value type: int / tstr.

   *  crit (label: 2): REQUIRED.  Criticality marker.  Value type: [
      +label ]

   The criticality header MUST contain the tree_alg label.

   The envelope payload MUST be computed by the process defined for the
   tree_alg.

   The envelope payload MUST be detached, and recomputed by the
   verifier.

   One example of a Signed Inclusion Proof is a "transparent statement"
   as defined in [I-D.ietf-scitt-architecture].

# COSE_Sign1
18([

  # Protected Header
  h'a2012604588368747470733a2f2f73636974742e78797a2f75726e3a696574663a706172616d733a7472616e733a696e636c7573696f6e3a726663393136325f7368613235363a303a65343263333764326638306361613464323035353635376534303463386538363838313534346136663264313731356530663564616435643436343833633531',
  # {
  #   "alg" : "ES256",
  #   1 : -7,
  #   "tree_alg" : "RFC9162_SHA256",
  #   TBD_1 : 1,
  # }

  # Unprotected Header
  {
      # "inclusion-proof" : "h'3133312c322c302c3132392c3231362c36342c38382c33322c3235342c3132382c33392c34392c3131382c312c3230352c38372c3235332c3136312c31332c3136312c38352c3139302c3133322c3234312c3137332c34352c3132372c32302c35302c35342c31332c3134342c33332c3233372c3234382c3132382c32332c3138392c3133352c3932'"
      TBD_2 : h'3133312c322c302c3132392c3231362c36342c38382c33322c3235342c3132382c33392c34392c3131382c312c3230352c38372c3235332c3136312c31332c3136312c38352c3139302c3133322c3234312c3137332c34352c3132372c32302c35302c35342c31332c3134342c33332c3233372c3234382c3132382c32332c3138392c3133352c3932'
  },

  # Detached Payload

  # Signature
  h'4862c1dced27ceeb1f7a6277d13be127a8969a7171ae000ffa90ef5757b817ca8ee61d57645d1a087251a97f06eb61aec46ecf958e4a0fb94ae37f410c7f77ea'
])

3.2.1.  Array form CDDL

   signed-inclusion-proof = [
     signed-inclusion-proof: bstr .cbor smtr ; the payload is a merkle root, as described by the tree algorithm, and is detached.
     inclusion-proof: bstr .cbor inclusion-proof ; the inclusion-proof, as described in the tree algorithm
     leaf: bstr ; the leaf, as described in the tree algorithm
   ]

3.3.  Signed Consistency Proof

# COSE_Sign1
18([

  # Protected Header
  h'a2012604588568747470733a2f2f73636974742e78797a2f75726e3a696574663a706172616d733a7472616e733a636f6e73697374656e63793a726663393136325f7368613235363a303a66653830323733313736303163643537666461313064613135356265383466316164326437663134333233363064393032316564663838303137626438373563',
  # {
  #   "alg" : "ES256",
  #   1 : -7,
  #   "tree_alg" : "RFC9162_SHA256",
  #   TBD_1 : 1,
  # }

  # Unprotected Header
  {
      # "consistency-proof" : "h'3133312c312c312c3132392c3231362c36342c38382c33322c3235342c3132382c33392c34392c3131382c312c3230352c38372c3235332c3136312c31332c3136312c38352c3139302c3133322c3234312c3137332c34352c3132372c32302c35302c35342c31332c3134342c33332c3233372c3234382c3132382c32332c3138392c3133352c3932'"
      TBD_3 : h'3133312c312c312c3132392c3231362c36342c38382c33322c3235342c3132382c33392c34392c3131382c312c3230352c38372c3235332c3136312c31332c3136312c38352c3139302c3133322c3234312c3137332c34352c3132372c32302c35302c35342c31332c3134342c33332c3233372c3234382c3132382c32332c3138392c3133352c3932'
  },

  # Protected Payload
  h'fe8027317601cd57fda10da155be84f1ad2d7f1432360d9021edf88017bd875c',

  # Signature
  h'fe476fcddb783805fe344fc96837f4a5531c2e5a56d6f6353831e84e17ac69d4407a5a0d6eadf27f3a570bcf604181fd11b4692d3ac17b116c6226ba43726113'
])

3.3.1.  Array form CDDL

   signed-consistency-proof = [
     signed-consistency-proof: bstr .cbor smtr ; the payload is a merkle root, as described by the tree algorithm, and is *attached*.
     consistency-proof: bstr .cbor consistency-proof ; the consistency-proof, as described in the tree algorithm
   ]

4.  Merkle Tree Algorithms

   This document establishes a registry of merkle tree algorithms with
   the following initial contents:

   +============+================+===========+
   | Identifier | Tree Algorithm | Reference |
   +============+================+===========+
   | 0          | N/A            |           |
   +------------+----------------+-----------+
   | 1          | RFC9162_SHA256 | [RFC9162] |
   +------------+----------------+-----------+

          Table 1: Merke Tree Alogrithms

   Each tree algorithm defines:

   1.  How to compute a leaf from a payload and extra data, such as the
       current size of the tree.

   2.  How to compute the merkle root from a sequence of leaves.

   3.  How to compute an inclusion-proof for a leaf.

   4.  How to compute a consistency-proof for a leaf.

   Each specification MUST define how to encode each of these parameters
   in CBOR, and map them to:

   *  TBD_1 - (tree alg)

   *  TBD_2 - (inclusion proof)

   *  TBD_3 - (consistency proof)

   See Section 4.1 as an example.

4.1.  The RFC9162_SHA256 Tree Algorithm

   This section defines how to map the data structures described in
   [RFC9162] to the terminology defined in this document, using cbor and
   cose.

4.1.1.  Tree Algorithm

   The integer identifier for "tree-alg" is 1.  The string identifier
   for "tree-alg" is "RFC9162_SHA256".

4.1.2.  Tree Definition

   See [RFC9162], 2.1.1.  Definition of the Merkle Tree.

4.1.2.1.  Merkle Root

   The cbor representation of a merkle root is the bytestring
   represenation of MTH.

4.1.2.2.  Inclusion Proof

   See [RFC9162], 2.1.3.1.  Generating an Inclusion Proof.

   The cbor representation of the inclusion proof is:

   inclusion-proof = #6.1234([
       tree-size: int
       leaf-index: int
       inclusion-path: [+ bstr]
   ])

4.1.2.3.  Consistency Proof

   See [RFC9162], 2.1.4.1.  Generating a Consistency Proof.

   The cbor representation of the consistency proof is:

   consistency-proof = #6.1234([
       tree-size-1: int ; size of the tree, when the previous root was produced.
       tree-size-2: int ; size of the tree, when the latest root was produced.
       consistency-path: [+ bstr] ; consistency path, from previous root to latest root.
   ])

   Editors note: tree-size-1, could be ommited, if an inclusion-proof is
   always present, since the inclusion proof contains, tree-size-1.

4.2.  Signed Proofs

   In a signed inclusion proof, the previous merkle tree root, maps to
   tree-size-1, and is a detached payload.  In a signed consistency
   proof, the latest merkle tree root, maps to tree-size-2, and is an
   attached payload.

5.  Privacy Considerations

   See the privacy considerations section of:

   *  [RFC9162]

   *  [RFC8152]

5.1.  Leaf Blinding

   In cases where a single merkle root and multiple inclusion paths are
   used to prove inclusion for multiple payloads.  There is a risk that
   an attacker may be able to learn the content of undisclosed payloads,
   by brute forcing the values adjacent to the disclosed payloads
   through application of the cryptographic hash function and comparison
   to the the disclosed inclusion paths.  This kind of attack can be
   mitigated by including a cryptographic nonce in the construction of
   the leaf, however this nonce must then disclosed along side an
   inclusion proof which increases the size of multiple payload signed
   inclusion proofs.

   Tree algorithm designers are encouraged to comment on this property
   of their leaf construction algorithm.

6.  Security Considerations

   See the privacy considerations section of:

   *  [RFC9162]

   *  [RFC8152]

6.1.  Hash Function Agility

   The choice of cryptographic hash function is the primary primitive
   impacting the security of authenticating payload inclusion in a
   merkle root.  Tree algorithm designers should review the latest
   guidance on selecting a suitable cryptographic hash function.

7.  IANA Considerations

7.1.  Additions to Existing Registries

7.1.1.  New Entries to the COSE Header Parameters Registry

   This document requests IANA to add new values to the 'COSE
   Algorithms' and to the 'COSE Header Algorithm Parameters' registries
   in the 'Standards Action With Expert Review category.

7.1.1.1.  COSE Header Algorithm Parameters

   *  Name: tree_alg

   *  Label: TBD_1

   *  Value type: tree_alg

   *  Value registry: See Section 7.1.2

   *  Description: Merkle tree algorithm used to produce a COSE Sign1
      payload.

   *  Name: inclusion_proof

   *  Label: TBD_2

   *  Value type: inclusion_proof

   *  Value registry: See Section 7.1.2

   *  Description: Merkle tree inclusion proof for the given tree_alg.

   *  Name: consistency_proof

   *  Label: TBD_2

   *  Value type: consistency_proof

   *  Value registry: See Section 7.1.2

   *  Description: Merkle tree consistency proof for the given tree_alg.

7.1.2.  Tree Algorithms

   IANA will be asked to establish a registry of tree algorithm
   identifiers, named "Tree Algorithms" to be administered under a
   Specification Required policy [RFC8126].

   Template:

   *  Identifier: The two-byte identifier for the algorithm

   *  Tree Algorithm: The name of the algorithm

   *  Reference: Where this algorithm is defined

   Initial contents: Provided in Table 1

8.  References

8.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <https://www.rfc-editor.org/rfc/rfc6234>.

   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "Certificate
              Transparency", RFC 6962, DOI 10.17487/RFC6962, June 2013,
              <https://www.rfc-editor.org/rfc/rfc6962>.

   [RFC6979]  Pornin, T., "Deterministic Usage of the Digital Signature
              Algorithm (DSA) and Elliptic Curve Digital Signature
              Algorithm (ECDSA)", RFC 6979, DOI 10.17487/RFC6979, August
              2013, <https://www.rfc-editor.org/rfc/rfc6979>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/rfc/rfc8032>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/rfc/rfc8126>.

   [RFC8152]  Schaad, J., "CBOR Object Signing and Encryption (COSE)",
              RFC 8152, DOI 10.17487/RFC8152, July 2017,
              <https://www.rfc-editor.org/rfc/rfc8152>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC8949]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", STD 94, RFC 8949,
              DOI 10.17487/RFC8949, December 2020,
              <https://www.rfc-editor.org/rfc/rfc8949>.

   [RFC9162]  Laurie, B., Messeri, E., and R. Stradling, "Certificate
              Transparency Version 2.0", RFC 9162, DOI 10.17487/RFC9162,
              December 2021, <https://www.rfc-editor.org/rfc/rfc9162>.

8.2.  Informative References

   [I-D.ietf-cose-countersign]
              Schaad, J., "CBOR Object Signing and Encryption (COSE):
              Countersignatures", Work in Progress, Internet-Draft,
              draft-ietf-cose-countersign-10, 20 September 2022,
              <https://datatracker.ietf.org/doc/html/draft-ietf-cose-
              countersign-10>.

   [I-D.ietf-scitt-architecture]
              Birkholz, H., Delignat-Lavaud, A., Fournet, C., and Y.
              Deshpande, "An Architecture for Trustworthy and
              Transparent Digital Supply Chains", Work in Progress,
              Internet-Draft, draft-ietf-scitt-architecture-01, 13 March
              2023, <https://datatracker.ietf.org/doc/html/draft-ietf-
              scitt-architecture-01>.

Appendix A.  Blinding Example

   Implementers wishing to leverage this tree algorithm with multiple
   inclusion proofs, may prepend payload with extra data before applying
   the tree algorithm, where extra data is a cryptographic nonce.

Authors' Addresses

   Orie Steele
   Transmute
   United States
   Email: orie@transmute.industries


   Henk Birkholz
   Fraunhofer SIT
   Rheinstrasse 75
   64295 Darmstadt
   Germany
   Email: henk.birkholz@sit.fraunhofer.de


   Antoine Delignat-Lavaud
   Microsoft
   United Kingdom
   Email: antdl@microsoft.com


   Cedric Fournet
   Microsoft
   United Kingdom
   Email: fournet@microsoft.com
